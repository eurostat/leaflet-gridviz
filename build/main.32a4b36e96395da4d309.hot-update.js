"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateleaflet_gridviz"]("main",{

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\");\n/* harmony import */ var gridviz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gridviz */ \"./node_modules/gridviz/src/index.js\");\n/* harmony import */ var _L_CanvasLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./L.CanvasLayer.js */ \"./src/L.CanvasLayer.js\");\n/* harmony import */ var _L_CanvasLayer_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_L_CanvasLayer_js__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\n// define our projection\r\nproj4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defs('EPSG:3035', '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs')\r\n\r\n/** An extension of L.CanvasLayer (leaflet-canvas-layer) for integrating gridviz into Leaflet\r\n *  @description \r\n *  methods\tdescription\r\n    needRedraw - will schedule next frame call for drawLayer\r\n    delegate(object) - optionaly set receiver of the events if not 'inheriting' from L.CanvasLayer\r\n * \r\n */\r\nL.GridvizLayer = function (opts) {\r\n    opts = opts || {};\r\n\r\n    // Ensure it sits in an animated pane and doesn’t redraw during zoom frames\r\n    this.options = Object.assign({\r\n        pane: opts.pane || 'overlayPane',\r\n        updateWhenZooming: false,\r\n        updateWhenIdle: true\r\n    }, opts);\r\n\r\n    this.proj = opts.proj || 'EPSG:3035';\r\n    this.gridvizMap = null;\r\n    this.onLayerDidMountCallback = opts.onLayerDidMountCallback || null;\r\n\r\n    this.onLayerDidMount = function () {\r\n        this.buildGridvizMap();\r\n\r\n        if (this.onLayerDidMountCallback) this.onLayerDidMountCallback(this.gridvizMap);\r\n\r\n        // ① Make canvas zoom-animated like other Leaflet layers\r\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-animated');\r\n        this._canvas.style.willChange = 'transform';\r\n\r\n        // ② Wire animation events using the same transform math as GridLayer\r\n        this._animating = false;\r\n\r\n        this._onZoomAnim = (e) => {\r\n            this._animating = true;\r\n\r\n            // scale from current zoom → e.zoom in this CRS\r\n            const scale = this._map.getZoomScale(e.zoom);\r\n            // same origin math GridLayer uses\r\n            const origin = this._map._getCenterOffset(e.center)\r\n                ._multiplyBy(-scale)\r\n                .subtract(this._map._getMapPanePos());\r\n\r\n            L.DomUtil.setTransform(this._canvas, origin, scale);\r\n        };\r\n\r\n        this._onZoomEnd = () => {\r\n            this._animating = false;\r\n            // reset transform to identity and repaint once at the final zoom\r\n            L.DomUtil.setTransform(this._canvas, L.point(0, 0), 1);\r\n            this.needRedraw();\r\n        };\r\n\r\n        this._map.on('zoomanim', this._onZoomAnim, this);\r\n        this._map.on('zoomend', this._onZoomEnd, this);\r\n\r\n        // (keep your resize observer code unchanged) …\r\n        const mapContainer = this._map._container;\r\n        const resizeObserver = new ResizeObserver((entries) => {\r\n            window.requestAnimationFrame(() => {\r\n                if (!Array.isArray(entries) || !entries.length) return;\r\n                if (this.gridvizMap.h !== mapContainer.clientHeight || this.gridvizMap.w !== mapContainer.clientWidth) {\r\n                    this.gridvizMap.h = mapContainer.clientHeight;\r\n                    this.gridvizMap.w = mapContainer.clientWidth;\r\n                    this.gridvizMap.geoCanvas.h = mapContainer.clientHeight;\r\n                    this.gridvizMap.geoCanvas.w = mapContainer.clientWidth;\r\n                    this._canvas.setAttribute('width', '' + this.gridvizMap.w);\r\n                    this._canvas.setAttribute('height', '' + this.gridvizMap.h);\r\n                    this.gridvizMap.redraw();\r\n                }\r\n            });\r\n        });\r\n        resizeObserver.observe(mapContainer);\r\n    };\r\n\r\n    // Prevent CanvasLayer from redrawing on every zoom tick; we animate via CSS\r\n    this.getEvents = function () {\r\n        const ev = L.CanvasLayer.prototype.getEvents.call(this);\r\n        delete ev.zoom;          // drop per-frame zoom draws\r\n        ev.zoomanim = this._onZoomAnim; // CSS transform instead\r\n        ev.zoomend = this._onZoomEnd;  // repaint once\r\n        return ev;\r\n    };\r\n\r\n    this.onLayerWillUnmount = function () {\r\n        if (this._map) {\r\n            this._map.off('zoomanim', this._onZoomAnim, this);\r\n            this._map.off('zoomend', this._onZoomEnd, this);\r\n        }\r\n        this.gridvizMap.destroy();\r\n    };\r\n\r\n    // Redraw only when not animating\r\n    this.onDrawLayer = function () {\r\n        if (this._animating) return;\r\n\r\n        const geoCenter = this.leafletToGeoCenter(this._map.getCenter());\r\n        const zoomFactor = this.leafletZoomToGridvizZoom();\r\n\r\n        this.gridvizMap.setView(geoCenter[0], geoCenter[1], zoomFactor);\r\n        this.gridvizMap.redraw();\r\n    };\r\n\r\n\r\n    /**\r\n     * @description Converts gridviz geoCenter to leaflet center\r\n     * proj4(fromProjection, toProjection, [coordinates])\r\n     * @param {number} x\r\n     * @param {number} y\r\n     */\r\n    this.geoCenterToLeaflet = function (x, y) {\r\n        let xy = (0,proj4__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.proj, 'WGS84', [x, y])\r\n        return [xy[1], xy[0]] // leaflet uses [lat,lon]\r\n    }\r\n\r\n    /**\r\n     * @description Converts leaflet center to gridviz projection's geoCenter\r\n     * proj4(fromProjection, toProjection, [coordinates])\r\n     * @param {{lng: number, lat: number}} latLon leaflet latLon object\r\n     */\r\n    this.leafletToGeoCenter = function (latLon) {\r\n        return (0,proj4__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.proj, [latLon.lng, latLon.lat])\r\n    }\r\n\r\n    /**\r\n     * @description Converts leaflet zoom level to gridviz zoom factor (pixel size, in ground m)\r\n     *@deprecated\r\n     */\r\n    this.leafletZoomToGridvizZoom = function () {\r\n        return this.getMetresPerPixel()\r\n    }\r\n\r\n    /**\r\n     * @description Calculates meters per pixel at the current leaflet zoom level\r\n     *\r\n     */\r\n    this.getMetresPerPixel = function () {\r\n        // get map center\r\n        let centerLatLng = this._map.getCenter()\r\n\r\n        // convert to containerpoint (pixels)\r\n        let pointC = this._map.latLngToContainerPoint(centerLatLng)\r\n        let pointX = [pointC.x + 1, pointC.y] // add one pixel to x\r\n\r\n        // convert containerpoints to latlng's\r\n        let latLngC = this._map.containerPointToLatLng(pointC)\r\n        let latLngX = this._map.containerPointToLatLng(pointX)\r\n\r\n        // convert to our projection\r\n        let projCenter = this.leafletToGeoCenter(latLngC)\r\n        let projX = this.leafletToGeoCenter(latLngX)\r\n        let difference = projX[0] - projCenter[0]\r\n\r\n        //console.log('zoom factor: ' + difference + '. Zoom level: ' + this._map._zoom)\r\n        return difference\r\n    }\r\n\r\n    /**\r\n     * @description build a gridviz app and add a layer to it\r\n     * gridviz api: https://eurostat.github.io/gridviz/docs/reference\r\n     * Uses (optionally):\r\n     * opts.container\r\n     * opts.selectionRectangleColor\r\n     * opts.selectionRectangleWidthPix\r\n     * opts.legendDivId\r\n     */\r\n    this.buildGridvizMap = function () {\r\n        let geoCenter = this.leafletToGeoCenter(this._map.getCenter())\r\n        opts.container = opts.container || this._canvas.parentElement\r\n        this.gridvizMap = new gridviz__WEBPACK_IMPORTED_MODULE_1__.Map(opts.container, {\r\n            canvas: this._canvas,\r\n            w: window.innerWidth,\r\n            h: window.innerHeight,\r\n            x: geoCenter[0],\r\n            y: geoCenter[1],\r\n            z: this.leafletZoomToGridvizZoom(),\r\n            disableZoom: true,\r\n            transparentBackground: true,\r\n            selectionRectangleColor: opts.selectionRectangleColor,\r\n            selectionRectangleWidthPix: opts.selectionRectangleWidthPix,\r\n            legendContainer: opts.legendContainer,\r\n            tooltip: { parentElement: document.body },\r\n        })\r\n    }\r\n}\r\n\r\nL.GridvizLayer.prototype = new L.CanvasLayer() // -- setup prototype\r\n\n\n//# sourceURL=webpack://leaflet-gridviz/./src/main.js?\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("fc49c8572a3862133e90")
/******/ })();
/******/ 
/******/ }
);